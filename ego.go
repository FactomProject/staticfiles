// Generated by ego.
// DO NOT EDIT

package main

import (
	"fmt"
	"html"
	"io"
)

var _ = fmt.Sprint("") // just so that we can keep the fmt import for now
//line template.ego:1
func GenerateTemplate(w io.Writer, pkg string, files []*file) error {
//line template.ego:2
	_, _ = io.WriteString(w, "\n")
//line template.ego:3
	_, _ = io.WriteString(w, "\npackage ")
//line template.ego:3
	_, _ = io.WriteString(w, html.EscapeString(fmt.Sprintf("%v", pkg)))
//line template.ego:4
	_, _ = io.WriteString(w, "\n\nimport (\n  \"compress/gzip\"\n  \"io\"\n  \"net/http\"\n  \"strconv\"\n  \"strings\"\n  \"time\"\n  \"unsafe\"\n)\n\ntype file struct {\n  data             string\n  mime             string\n  mtime            time.Time\n  // size is the size before compression. If 0, it means the data is uncompressed\n  size int\n}\n\nvar files = map[string]*file{")
//line template.ego:23
	for _, f := range files {
//line template.ego:24
		_, _ = io.WriteString(w, "\n  ")
//line template.ego:24
		_, _ = fmt.Fprintf(w, "%v", fmt.Sprintf("%q", f.name))
//line template.ego:24
		_, _ = io.WriteString(w, ": {\n    data: ")
//line template.ego:25
		_, _ = fmt.Fprintf(w, "%v", fmt.Sprintf("%q", f.data))
//line template.ego:25
		_, _ = io.WriteString(w, ",\n    mime: ")
//line template.ego:26
		_, _ = fmt.Fprintf(w, "%v", fmt.Sprintf("%q", f.mime))
//line template.ego:26
		_, _ = io.WriteString(w, ",\n    mtime: time.Unix(")
//line template.ego:27
		_, _ = io.WriteString(w, html.EscapeString(fmt.Sprintf("%v", f.mtime.Unix())))
//line template.ego:27
		_, _ = io.WriteString(w, ", 0),\n    size: ")
//line template.ego:28
		_, _ = io.WriteString(w, html.EscapeString(fmt.Sprintf("%v", f.size)))
//line template.ego:28
		_, _ = io.WriteString(w, ",\n  },")
//line template.ego:29
	}
//line template.ego:30
	_, _ = io.WriteString(w, "\n}\n\nfunc ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n  f, ok := files[strings.TrimPrefix(req.URL.Path, \"/\")]\n  if !ok {\n    http.NotFound(rw, req)\n    return\n  }\n  header := rw.Header()\n  if !f.mtime.IsZero() {\n    if t, err := time.Parse(http.TimeFormat, req.Header.Get(\"If-Modified-Since\")); err == nil && f.mtime.Before(t.Add(1*time.Second)) {\n      rw.WriteHeader(http.StatusNotModified)\n      return\n    }\n    header.Set(\"Last-Modified\", f.mtime.UTC().Format(http.TimeFormat))\n  }\n  header.Set(\"Content-Type\", f.mime)\n\n  // unsafe hack to avoid a copy\n  b := *(*[]byte)(unsafe.Pointer(&f.data))\n  // Check if the asset is compressed in the binary\n  if f.size == 0 {\n    header.Set(\"Content-Length\", strconv.Itoa(len(b)))\n    rw.Write(b)\n  } else {\n    if strings.Contains(req.Header.Get(\"Accept-Encoding\"), \"gzip\") {\n      header.Set(\"Content-Encoding\", \"gzip\")\n      header.Set(\"Content-Length\", strconv.Itoa(len(b)))\n      rw.Write(b)\n    } else {\n      reader, err := gzip.NewReader(strings.NewReader(f.data))\n      if err != nil {\n        http.Error(rw, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n        return\n      }\n      header.Set(\"Content-Length\", strconv.Itoa(f.size))\n      io.Copy(rw, reader)\n      reader.Close()\n    }\n  }\n}\n\nfunc MTime(file string) (t time.Time) {\n  if f, ok := files[file]; ok {\n    t = f.mtime\n  }\n  return\n}\n")
	return nil
}
